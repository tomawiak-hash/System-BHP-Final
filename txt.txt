import streamlit as st
import google.generativeai as genai
from PyPDF2 import PdfReader
import os
import re
from docxtpl import DocxTemplate
from io import BytesIO
import datetime
from docx import Document

# ----- Konfiguracja Aplikacji
st.set_page_config(page_title="Inteligentny Generator Szkole≈Ñ BHP", page_icon="üéì", layout="wide")

# Wstaw tutaj sw√≥j klucz API z Google AI Studio
genai.configure(api_key="AIzaSyBYtQ-Y7nfP7h-4fqT4gMDRzed0b-IVVjw")

# ----- Inicjalizacja "pamiƒôci" aplikacji (session_state) - KOMPLETNA
if 'etap' not in st.session_state:
    st.session_state.etap = 1
if 'finalna_tresc' not in st.session_state:
    st.session_state.finalna_tresc = ""
if 'zapisana_firma' not in st.session_state:
    st.session_state.zapisana_firma = ""
if 'wybrany_zawod' not in st.session_state:
    st.session_state.wybrany_zawod = ""
if 'opis_zawodu' not in st.session_state:
    st.session_state.opis_zawodu = ""
if 'spis_tresci_do_tematyki' not in st.session_state:
    st.session_state.spis_tresci_do_tematyki = []
if 'cel_szkolenia_text' not in st.session_state:
    st.session_state.cel_szkolenia_text = ""
if 'tematyka_z_godzinami' not in st.session_state:
    st.session_state.tematyka_z_godzinami = []

# ----- Funkcje Aplikacji
def wczytaj_liste_zawodow_lokalnie():
    """
    Zwraca sta≈ÇƒÖ, lokalnƒÖ listƒô zawod√≥w.
    """
    lista_zawodow = {
        "Administrator baz danych (252101)": "252101",
        "Specjalista administracji publicznej (242217)": "242217",
        "Specjalista do spraw kadr (242307)": "242307",
        "Kierownik biura (334101)": "334101",
        "Asystent dyrektora (334302)": "334302"
    }
    return lista_zawodow

@st.cache_data
def pobierz_opis_zawodu_lokalnie(kod_zawodu):
    """
    Wczytuje opis zawodu z lokalnego pliku PDF z folderu 'baza_zawodow'.
    """
    sciezka_pliku = os.path.join('baza_zawodow', f'{kod_zawodu}.pdf')
    try:
        pelny_tekst = ""
        with open(sciezka_pliku, "rb") as f:
            pdf_reader = PdfReader(f)
            for page in pdf_reader.pages:
                pelny_tekst += (page.extract_text() or "") + "\n"
        return pelny_tekst
    except FileNotFoundError:
        return f"B≈ÇƒÖd: Brak pliku {kod_zawodu}.pdf w folderze 'baza_zawodow'."
    except Exception as e:
        return f"B≈ÇƒÖd odczytu pliku PDF {kod_zawodu}.pdf: {e}"

@st.cache_data
def laduj_baze_wiedzy(folder_path='baza_wiedzy'):
    """
    Wczytuje tre≈õƒá wszystkich plik√≥w .txt i .pdf z podanego folderu.
    """
    print(f"--- Wczytywanie bazy wiedzy z folderu: {folder_path} ---")
    pelny_tekst = ""
    if not os.path.isdir(folder_path):
        st.warning(f"Folder '{folder_path}' nie istnieje! Baza wiedzy nie zostanie za≈Çadowana.")
        return ""
    for nazwa_pliku in os.listdir(folder_path):
        sciezka_pliku = os.path.join(folder_path, nazwa_pliku)
        try:
            if nazwa_pliku.lower().endswith('.pdf'):
                with open(sciezka_pliku, "rb") as f:
                    pdf_reader = PdfReader(f)
                    if pdf_reader.is_encrypted:
                        print(f"Plik {nazwa_pliku} jest zaszyfrowany.")
                        continue
                    for page in pdf_reader.pages:
                         try:
                             pelny_tekst += (page.extract_text() or "") + "\n\n"
                         except Exception as page_e:
                             print(f"B≈ÇƒÖd odczytu strony w pliku {nazwa_pliku}: {page_e}")
            elif nazwa_pliku.lower().endswith('.txt'):
                with open(sciezka_pliku, "r", encoding="utf-8") as f:
                    pelny_tekst += f.read() + "\n\n"
        except Exception as e:
            print(f"B≈ÇƒÖd podczas wczytywania pliku {nazwa_pliku}: {e}")
    return pelny_tekst

def generuj_kompletne_szkolenie(firma, nazwa_zawodu, opis_zawodu, dodatkowe_zagrozenia):
    """
    POPRAWKA: Definicja funkcji przyjmuje teraz argument 'dodatkowe_zagrozenia'
    i NIE u≈ºywa 'bazy_wiedzy', aby uniknƒÖƒá b≈Çƒôd√≥w limitu token√≥w.
    """
    model = genai.GenerativeModel('gemini-pro-latest')
    
    prompt = f"""
    Jeste≈õ ekspertem BHP i metodykiem szkole≈Ñ. Twoim zadaniem jest stworzenie kompletnego materia≈Çu szkoleniowego dla stanowiska '{nazwa_zawodu}' w firmie '{firma}'.

    MUSISZ RYGORYSTYCZNIE PRZESTRZEGAƒÜ PONI≈ªSZEJ STRUKTURY I ZAKRESU TEMATYCZNEGO, kt√≥re sƒÖ oparte na Za≈ÇƒÖczniku nr 1 do RozporzƒÖdzenia Ministra Gospodarki i Pracy z dnia 27 lipca 2004 r.

    Twoje zadanie sk≈Çada siƒô z dw√≥ch czƒô≈õci. Rozwi≈Ñ KA≈ªDY z poni≈ºszych punkt√≥w:

    CZƒò≈öƒÜ 1: INSTRUKTA≈ª OG√ìLNY
    (Tematy z ramowego programu instrukta≈ºu og√≥lnego)
    1. Istota bezpiecze≈Ñstwa i higieny pracy.
    2. Zakres obowiƒÖzk√≥w i uprawnie≈Ñ pracodawcy, pracownik√≥w oraz poszczeg√≥lnych kom√≥rek organizacyjnych zak≈Çadu pracy i organizacji spo≈Çecznych w zakresie bezpiecze≈Ñstwa i higieny pracy.
    3. Odpowiedzialno≈õƒá za naruszenie przepis√≥w lub zasad bezpiecze≈Ñstwa i higieny pracy.
    4. Zasady poruszania siƒô na terenie zak≈Çadu pracy.
    5. Zagro≈ºenia wypadkowe i zagro≈ºenia dla zdrowia wystƒôpujƒÖce w zak≈Çadzie i podstawowe ≈õrodki zapobiegawcze.
    6. Podstawowe zasady bezpiecze≈Ñstwa i higieny pracy zwiƒÖzane z obs≈ÇugƒÖ urzƒÖdze≈Ñ technicznych oraz transportem wewnƒÖtrzzak≈Çadowym.
    7. Zasady przydzia≈Çu odzie≈ºy roboczej i obuwia roboczego oraz ≈õrodk√≥w ochrony indywidualnej, w tym w odniesieniu do stanowiska pracy instruowanego.
    8. PorzƒÖdek i czysto≈õƒá w miejscu pracy - ich wp≈Çyw na zdrowie i bezpiecze≈Ñstwo pracownika.
    9. Profilaktyczna opieka lekarska - zasady jej sprawowania w odniesieniu do stanowiska instruowanego.
    10. Podstawowe zasady ochrony przeciwpo≈ºarowej oraz postƒôpowania w razie po≈ºaru.
    11. Postƒôpowanie w razie wypadku, w tym organizacja i zasady udzielania pierwszej pomocy.
    
    CZƒò≈öƒÜ 2: INSTRUKTA≈ª STANOWISKOWY
    (Tematy z ramowego programu instrukta≈ºu stanowiskowego)
    1. Przygotowanie pracownika do wykonywania pracy (om√≥wienie warunk√≥w pracy, czynnik√≥w ≈õrodowiska pracy, ryzyka zawodowego).
    2. Pokaz przez instruktora sposobu wykonywania pracy zgodnie z przepisami i zasadami BHP.
    3. Pr√≥bne wykonanie zadania przez pracownika pod kontrolƒÖ instruktora.
    4. Samodzielna praca pracownika pod nadzorem instruktora.
    5. Om√≥wienie i ocena przebiegu wykonywania pracy przez pracownika.

    WYTYCZNE DODATKOWE:
    -   **PERSONALIZACJA:** Podczas rozwijania punkt√≥w Instrukta≈ºu Stanowiskowego (Czƒô≈õƒá 2), musisz bezpo≈õrednio nawiƒÖzywaƒá do zagro≈ºe≈Ñ i zada≈Ñ z 'OFICJALNEGO OPISU ZAWODU' oraz 'DODATKOWYCH ZAGRO≈ªE≈É' podanych poni≈ºej.
    -   **G≈ÅƒòBIA MERYTORYCZNA:** Ka≈ºdy z 16 powy≈ºszych punkt√≥w (11+5) rozwi≈Ñ w spos√≥b wyczerpujƒÖcy (minimum 2-3 akapity lub szczeg√≥≈Çowa lista wypunktowana).
    -   **JAKO≈öƒÜ I JƒòZYK:** Pisz profesjonalnym, formalnym, ale zrozumia≈Çym jƒôzykiem. Powo≈Çuj siƒô na akty prawne (np. "Zgodnie z Kodeksem Pracy...").
    -   **FORMATOWANIE:** U≈ºywaj Markdown. Tytu≈Ç g≈Ç√≥wny jako nag≈Ç√≥wek poziomu 1 (#), Czƒô≈õci jako poziom 2 (##), a poszczeg√≥lne punkty jako poziom 3 (###).

    --- OFICJALNY OPIS ZAWODU (DLA PERSONALIZACJI) ---
    {opis_zawodu}
    
    --- DODATKOWE ZAGRO≈ªENIA WSKAZANE PRZEZ U≈ªYTKOWNIKA ---
    {dodatkowe_zagrozenia}
    
    Stw√≥rz teraz kompletny materia≈Ç szkoleniowy zgodny z powy≈ºszymi wytycznymi.
    """
    
    try:
        response = model.generate_content(prompt, generation_config=genai.types.GenerationConfig(temperature=0.5))
        
        # Poprawione wyra≈ºenie regularne, aby pasowa≈Ço do nowej, sta≈Çej struktury
        st.session_state.spis_tresci_do_tematyki = re.findall(r"^(?:\d+)\.\s.*", response.text, re.MULTILINE)
        
        return response.text
    except Exception as e:
        st.error(f"WystƒÖpi≈Ç b≈ÇƒÖd podczas komunikacji z AI: {e}")
        if "429" in str(e):
             st.warning("Przekroczono limit zapyta≈Ñ lub token√≥w w darmowym planie Google AI. Spr√≥buj ponownie za chwilƒô.")
        return "B≈ÇƒÖd generowania tre≈õci."

@st.cache_data
def generuj_cel_szkolenia(nazwa_szkolenia):
    """
    Generuje kr√≥tki, oficjalny cel szkolenia.
    """
    try:
        model = genai.GenerativeModel('gemini-pro-latest')
        prompt = f"Napisz kr√≥tki, jednozdaniowy, oficjalny cel szkolenia wstƒôpnego BHP dla stanowiska '{nazwa_szkolenia}'. Cel zwiƒôz≈Çy i formalny."
        response = model.generate_content(prompt, generation_config=genai.types.GenerationConfig(temperature=0.5))
        return response.text
    except Exception as e:
        return f"B≈ÇƒÖd generowania celu: {e}"

@st.cache_data
def generuj_test_bhp(_finalna_tresc): # U≈ºywamy _finalna_tresc, aby pom√≥c cache
    """
    Generuje test wielokrotnego wyboru (ABC) na podstawie wygenerowanej tre≈õci szkolenia.
    """
    model = genai.GenerativeModel('gemini-pro-latest')
    prompt = f"""
    Jeste≈õ egzaminatorem BHP. Otrzymujesz poni≈ºej kompletny materia≈Ç szkoleniowy.
    Twoim zadaniem jest stworzenie na jego podstawie testu sprawdzajƒÖcego wiedzƒô.

    WYTYCZNE TESTU:
    1.  **Liczba pyta≈Ñ:** Dok≈Çadnie 10 pyta≈Ñ.
    2.  **Poziom trudno≈õci:** ≈Åatwy (pytania o podstawowe fakty i zasady z tekstu).
    3.  **Format pyta≈Ñ:** Pytania zamkniƒôte, wielokrotnego wyboru z trzema odpowiedziami (A, B, C).
    4.  **Klucz odpowiedzi:** Na samym ko≈Ñcu dokumentu dodaj sekcjƒô "KLUCZ ODPOWIEDZI" w formacie:
        1. A
        2. B
        3. C
        ...itd.

    --- MATERIA≈Å SZKOLENIOWY DO ANALIZY ---
    {_finalna_tresc}
    --- KONIEC MATERIA≈ÅU ---

    Stw√≥rz teraz kompletny test (10 pyta≈Ñ + klucz odpowiedzi).
    """
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        st.error(f"B≈ÇƒÖd AI podczas generowania testu: {e}")
        return "Nie uda≈Ço siƒô wygenerowaƒá testu."

@st.cache_data
def przypisz_godziny_do_tematow(_spis_tresci_lista):
    """
    Analizuje listƒô temat√≥w i przypisuje szacowanƒÖ liczbƒô godzin.
    """
    model = genai.GenerativeModel('gemini-pro-latest')
    tekst_spisu = "\n".join(_spis_tresci_lista)
    
    prompt = f"""
    Jeste≈õ metodykiem szkole≈Ñ BHP. Otrzymujesz poni≈ºszy spis g≈Ç√≥wnych temat√≥w szkolenia. Oszacuj, ile godzin lekcyjnych (45 min) potrzeba na realizacjƒô ka≈ºdego tematu.
    
    Odpowied≈∫ zwr√≥ƒá TYLKO w formacie listy: "Nazwa tematu BEZ NUMERACJI | X"
    
    Przyk≈Çad:
    Wprowadzenie do BHP | 1
    Zagro≈ºenia na stanowisku pracy | 2

    Oto spis tre≈õci do analizy:
    {tekst_spisu}
    """
    try:
        response = model.generate_content(prompt)
        tematyka = []
        if hasattr(response, 'text'):
            for linia in response.text.splitlines():
                if '|' in linia:
                    try:
                        czesci = linia.split('|')
                        # ZMIANA: Bierzemy 'nazwa' bezpo≈õrednio, bez usuwania numeracji
                        nazwa = czesci[0].strip() 
                        godziny = int(czesci[1].strip())
                        tematyka.append({"nazwa": nazwa, "godziny": godziny})
                    except (ValueError, IndexError):
                        continue
        else:
            st.error("Nie uda≈Ço siƒô uzyskaƒá odpowiedzi od AI przy przypisywaniu godzin.")
        
        # Zwracamy tyle wierszy ile by≈Ço w oryginalnym spisie
        return tematyka[:len(_spis_tresci_lista)] 
    except Exception as e:
        st.error(f"B≈ÇƒÖd AI przy przypisywaniu godzin: {e}")
        return []

# ----- Funkcja pomocnicza do generowania dokument√≥w .docx
def generuj_docx(nazwa_szablonu, kontekst, nazwa_pliku_wynikowego):
    """
    Wype≈Çnia szablon Worda i zwraca go jako obiekt BytesIO.
    """
    try:
        doc = DocxTemplate(nazwa_szablonu)
        doc.render(kontekst)
        bio = BytesIO()
        doc.save(bio)
        bio.seek(0)
        return bio
    except Exception as e:
        st.error(f"B≈ÇƒÖd generowania pliku '{nazwa_pliku_wynikowego}': {e}")
        st.warning(f"Upewnij siƒô, ≈ºe plik '{nazwa_szablonu}' istnieje i ma poprawne znaczniki.")
        return None

# ----- G≈Ç√≥wny interfejs aplikacji
st.title("üéì Inteligentny Generator Szkole≈Ñ BHP (zasilany przez Gemini)")

# --- Etap 1: Wyb√≥r zawodu i generowanie tre≈õci ---
if st.session_state.etap == 1:
    st.header("Krok 1: Wybierz zaw√≥d i wygeneruj kompletne szkolenie")
    
    lista_zawodow = wczytaj_liste_zawodow_lokalnie()
    baza_wiedzy_content = laduj_baze_wiedzy()

    wybrany_zawod_nazwa = st.selectbox("Wybierz zaw√≥d z listy:", options=list(lista_zawodow.keys()), index=None, placeholder="Wybierz zaw√≥d...")

    dodatkowe_zagrozenia = st.text_area("Wprowad≈∫ dodatkowe, specyficzne zagro≈ºenia dla tego stanowiska (opcjonalnie):", key="extra_hazards")

    nazwa_firmy = st.text_input("Wprowad≈∫ nazwƒô firmy:", key="firma_input", value="Przyk≈Çadowa Firma S.A.")
    
    if st.button("üöÄ Generuj kompletne szkolenie"):
        if not wybrany_zawod_nazwa:
            st.warning("Proszƒô wybraƒá zaw√≥d z listy.")
        else:
            with st.spinner(f"Analizujƒô dane i tworzƒô pe≈Çne szkolenie dla: {wybrany_zawod_nazwa}..."):
                kod_zawodu = lista_zawodow[wybrany_zawod_nazwa]
                opis_zawodu = pobierz_opis_zawodu_lokalnie(kod_zawodu)
                
                if "B≈ÇƒÖd:" in opis_zawodu:
                    st.error(opis_zawodu)
                else:
                    finalna_tresc = generuj_kompletne_szkolenie(nazwa_firmy, wybrany_zawod_nazwa, opis_zawodu, dodatkowe_zagrozenia)
                    if "B≈ÇƒÖd generowania tre≈õci." not in finalna_tresc:
                        st.session_state.finalna_tresc = finalna_tresc
                        st.session_state.zapisana_firma = nazwa_firmy or "Twoja Firma"
                        st.session_state.wybrany_zawod = wybrany_zawod_nazwa
                        
                        st.write("--- DEBUG: Rozpoczynam generowanie danych dodatkowych ---") # <-- DEBUG 1
                        with st.spinner("Generowanie celu szkolenia..."):
                            st.session_state.cel_szkolenia_text = generuj_cel_szkolenia(f"Szkolenie wstƒôpne BHP dla stanowiska '{wybrany_zawod_nazwa}'")
                        
                        st.write(f"--- DEBUG: Spis tre≈õci do analizy godzin ({len(st.session_state.spis_tresci_do_tematyki)} pozycji): ---") # <-- DEBUG 2
                        st.write(st.session_state.spis_tresci_do_tematyki) # <-- DEBUG 3 Wy≈õwietlamy spis

                        with st.spinner("Przypisywanie godzin do temat√≥w..."):
                            if st.session_state.spis_tresci_do_tematyki: 
                                st.session_state.tematyka_z_godzinami = przypisz_godziny_do_tematow(tuple(st.session_state.spis_tresci_do_tematyki)) 
                            else:
                                st.warning("Nie uda≈Ço siƒô wyodrƒôbniƒá spisu tre≈õci do analizy godzin.")
                                st.session_state.tematyka_z_godzinami = []
                        
                        st.write(f"--- DEBUG: Wynik przypisania godzin ({len(st.session_state.tematyka_z_godzinami)} pozycji): ---") # <-- DEBUG 4
                        st.write(st.session_state.tematyka_z_godzinami) # <-- DEBUG 5 Wy≈õwietlamy wynik godzin

                        st.write("--- DEBUG: Ko≈Ñczƒô generowanie danych dodatkowych ---") # <-- DEBUG 6


                        # Generujemy dane dodatkowe od razu
                        with st.spinner("Generowanie celu szkolenia..."):
                            st.session_state.cel_szkolenia_text = generuj_cel_szkolenia(f"Szkolenie wstƒôpne BHP dla stanowiska '{wybrany_zawod_nazwa}'")
                        with st.spinner("Przypisywanie godzin do temat√≥w..."):
                            if st.session_state.spis_tresci_do_tematyki:
                                st.session_state.tematyka_z_godzinami = przypisz_godziny_do_tematow(tuple(st.session_state.spis_tresci_do_tematyki))
                            else:
                                st.warning("Nie uda≈Ço siƒô wyodrƒôbniƒá spisu tre≈õci do analizy godzin.")
                                st.session_state.tematyka_z_godzinami = []

                        st.session_state.etap = 2
                        st.rerun()

# --- Etap 2: Weryfikacja i przej≈õcie do dokumentacji ---
elif st.session_state.etap == 2:
    st.header("‚úÖ Krok 2: Weryfikacja i pobieranie tre≈õci szkolenia")
    st.success("Pe≈Çna tre≈õƒá szkolenia zosta≈Ça wygenerowana.")

    with st.expander("Poka≈º/Ukryj tre≈õƒá szkolenia do weryfikacji"):
        st.markdown(st.session_state.finalna_tresc)

    st.markdown("---")
    st.subheader("1. Pobierz tre≈õƒá szkolenia")
    st.download_button(
        label="Pobierz tre≈õƒá szkolenia (.txt)",
        data=st.session_state.finalna_tresc.encode('utf-8'),
        file_name=f"Szkolenie_{st.session_state.wybrany_zawod}.txt",
        mime="text/plain",
        key="download_szkolenie_txt"
    )

    st.markdown("---")
    st.subheader("2. Przejd≈∫ do dokumentacji")
    if st.button("üìÑ Generuj dokumenty"):
        st.session_state.etap = 3
        st.rerun()
    if st.button("Stw√≥rz inne szkolenie"):
        st.session_state.etap = 1
        st.rerun()

# --- Etap 3: Generator Dokumentacji ---
elif st.session_state.etap == 3:
    st.header("‚úÖ Krok 3: Generator Dokumentacji")
    st.success("Wype≈Çnij potrzebne dane i generuj poszczeg√≥lne dokumenty.")

    st.markdown("---")
    st.subheader("Wsp√≥lne dane dla dokument√≥w:")

    st.caption("Format: Imiƒô Nazwisko, Miejsce Pracy, Funkcja, Data Urodzenia (DD.MM.RRRR). Ka≈ºdy uczestnik w nowej linii.")

    uczestnicy_input = st.text_area(
        # Etykieta pola
        "Lista uczestnik√≥w (ka≈ºdy w nowej linii, oddzielone przecinkami)",
        height=100,
        # Placeholder powtarzajƒÖcy format
        placeholder="Format: Imiƒô Nazwisko, Miejsce Pracy, Funkcja, Data Urodzenia (DD.MM.RRRR)",
        key="uczestnicy_lista_input"
    )
    uczestnicy_dane_lista = []
    if uczestnicy_input:
        for i, linia in enumerate(uczestnicy_input.strip().splitlines()):
            czesci = [czesc.strip() for czesc in linia.split(',')]
            print(f"DEBUG: Linia {i+1} Dziennika Lekcyjnego: {czesci}")
            if len(czesci) == 4:
                uczestnicy_dane_lista.append({
                    'index': i + 1, 'imie_nazwisko': czesci[0], 'miejsce_pracy': czesci[1],
                    'funkcja': czesci[2], 'data_urodzenia': czesci[3], 'ocena': '', 'uwagi': ''
                })

    col_daty1, col_daty2 = st.columns(2)
    with col_daty1:
        data_start = st.date_input("Data rozpoczƒôcia:", key="doc_data_start", value=datetime.date.today())
        nr_kursu = st.text_input("Numer kursu:", "01/BHP/2025", key="doc_nr_kursu")
        kierownik_kursu = st.text_input("Kierownik kursu:", "Anna Kowalska", key="doc_kierownik")
    with col_daty2:
        data_koniec = st.date_input("Data zako≈Ñczenia:", key="doc_data_koniec", value=datetime.date.today())
        miejscowosc = st.text_input("Miejscowo≈õƒá:", "≈Å√≥d≈∫", key="doc_miejscowosc")
        data_wystawienia_doc = st.date_input("Data wystawienia:", key="doc_data_wyst", value=datetime.date.today())

    st.markdown("---")

        # --- Generowanie Za≈õwiadczenia ---
    with st.container(border=True):
        st.subheader("üìÑ Wygeneruj Za≈õwiadczenie")
        imiona_uczestnikow = [u['imie_nazwisko'] for u in uczestnicy_dane_lista]
        wybrany_uczestnik_cert = st.selectbox("Wybierz uczestnika:", options=imiona_uczestnikow, key="cert_wybor_uczestnika", index=None, placeholder="Wybierz opcjƒô...")
        nr_zaswiadczenia_cert = st.text_input("Nr za≈õwiadczenia:", f"{nr_kursu}/1", key="cert_nr_zaswiadczenia")

        if st.button("Generuj Za≈õwiadczenie", key="btn_cert"):
            if wybrany_uczestnik_cert:
                dane_wybranego = next((u for u in uczestnicy_dane_lista if u['imie_nazwisko'] == wybrany_uczestnik_cert), None)
                if dane_wybranego:
                    with st.spinner("Generowanie..."):
                        nazwa_szkolenia_full = f"Szkolenie wstƒôpne BHP dla stanowiska '{st.session_state.wybrany_zawod}'"
                        cel_szkolenia_text = st.session_state.cel_szkolenia_text
                        context = {
                            'nazwa_organizatora_szkolenia': st.session_state.zapisana_firma,
                            'imie_nazwisko': dane_wybranego['imie_nazwisko'], 'data_urodzenia': dane_wybranego['data_urodzenia'],
                            'nazwa_szkolenia': nazwa_szkolenia_full, 'forma_szkolenia': "kurs (samokszta≈Çcenie kierowane)",
                            'nazwa_organizatora': st.session_state.zapisana_firma,
                            'dzien_rozpoczecia': data_start.strftime("%d.%m.%Y"), 'dzien_zakonczenia': data_koniec.strftime("%d.%m.%Y"),
                            'cel_szkolenia': cel_szkolenia_text, 'miejscowosc_szkolenia': miejscowosc,
                            'data_wystawienia_zaswiadczenia': data_wystawienia_doc.strftime("%d.%m.%Y"),
                            'nr_zaswiadczenia_wg_rejestru': nr_zaswiadczenia_cert
                        }
                        plik_docx = generuj_docx("certyfikat_szablon.docx", context, f"Certyfikat_{dane_wybranego['imie_nazwisko']}.docx")
                        if plik_docx:
                            st.download_button(label="Pobierz (.docx)", data=plik_docx, file_name=f"Certyfikat_{dane_wybranego['imie_nazwisko']}.docx", mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", key=f"dl_cert_{dane_wybranego['imie_nazwisko']}")
                else: st.error("Nie znaleziono danych uczestnika.")
            else: st.warning("Wybierz uczestnika.")

    st.markdown("---")

    # --- Generowanie Tematyki Szkolenia (NOWA METODA) ---
    with st.container(border=True):
        st.subheader("üìã Wygeneruj Tematykƒô Szkolenia")
        if st.button("Generuj Tematykƒô", key="btn_tematyka"):
            with st.spinner("Przygotowujƒô tematykƒô..."):
                tematyka_z_godzinami = st.session_state.tematyka_z_godzinami
                if tematyka_z_godzinami:
                    try:
                        doc = Document("tematyka_szablon_uproszczony.docx") # <-- U≈ºywamy uproszczonego szablonu
                        if doc.tables:
                            table = doc.tables[0]
                            for i, temat in enumerate(tematyka_z_godzinami):
                                row_cells = table.add_row().cells
                                row_cells[0].text = str(i + 1)
                                row_cells[1].text = temat.get('nazwa', '')
                                row_cells[2].text = str(temat.get('godziny', '?'))
                                row_cells[3].text = "0"
                            # Mo≈ºna dodaƒá kod do rysowania krawƒôdzi, je≈õli potrzeba
                            bio = BytesIO()
                            doc.save(bio)
                            bio.seek(0)
                            st.download_button(label="Pobierz (.docx)", data=bio, file_name=f"Tematyka_{st.session_state.wybrany_zawod}.docx", mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", key="dl_tematyka")
                        else: st.error("Brak tabeli w szablonie.")
                    except Exception as e: st.error(f"B≈ÇƒÖd: {e}")
                else: st.error("Brak danych tematyki.")

    st.markdown("---")

    # --- Generowanie Wykazu Uczestnik√≥w (NOWA METODA) ---
    with st.container(border=True):
        st.subheader("üë• Wygeneruj Wykaz Uczestnik√≥w")
        if st.button("Generuj Wykaz", key="btn_wykaz"):
             if uczestnicy_dane_lista:
                with st.spinner("Generowanie..."):
                    try:
                        doc = Document("wykaz_uczestnikow_szablon_uproszczony.docx") # <-- U≈ºywamy uproszczonego szablonu
                        if doc.tables:
                            table = doc.tables[0]
                            for i, u in enumerate(uczestnicy_dane_lista):
                                row_cells = table.add_row().cells
                                row_cells[0].text = str(i + 1)
                                row_cells[1].text = u.get('imie_nazwisko', '')
                                row_cells[2].text = u.get('miejsce_pracy', '')
                                row_cells[3].text = u.get('funkcja', '')
                                row_cells[4].text = u.get('data_urodzenia', '')
                                row_cells[5].text = "" # Obecno≈õƒá
                            # Mo≈ºna dodaƒá kod do rysowania krawƒôdzi
                            bio = BytesIO()
                            doc.save(bio)
                            bio.seek(0)
                            st.download_button(label="Pobierz (.docx)", data=bio, file_name=f"Wykaz_{st.session_state.wybrany_zawod}.docx", mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", key="dl_wykaz")
                        else: st.error("Brak tabeli w szablonie.")
                    except Exception as e: st.error(f"B≈ÇƒÖd: {e}")
             else: st.warning("Wprowad≈∫ listƒô uczestnik√≥w.")

    st.markdown("---")

    # --- Generowanie Protoko≈Çu Egzaminu (NOWA METODA DLA TABELI + docxtpl dla reszty) ---
    with st.container(border=True):
        st.subheader("üìù Wygeneruj Protok√≥≈Ç Egzaminu")

        st.caption("Format: Imiƒô Nazwisko, Miejsce Pracy, Funkcja. Ka≈ºdy uczestnik w nowej linii.")
        komisja_input = st.text_area("Cz≈Çonkowie komisji)", height=80, key="egz_komisja")
        oceny_dict = {}
        if uczestnicy_dane_lista:
            st.write("**Oceny:**")
            for u in uczestnicy_dane_lista:
                oceny_dict[u['imie_nazwisko']] = st.selectbox(f"Ocena dla {u['imie_nazwisko']}:", ["brak", "2", "3", "4", "5"], key=f"ocena_{u['index']}")

        if st.button("Generuj Protok√≥≈Ç", key="btn_protokol"):
            if uczestnicy_dane_lista and komisja_input:
                with st.spinner("Generowanie..."):
                    try:
                        # Krok 1: Wype≈Çnij pola poza tabelƒÖ za pomocƒÖ docxtpl
                        doc_tpl = DocxTemplate("protokol_egzaminu_szablon_uproszczony.docx") # <-- U≈ºywamy uproszczonego szablonu
                        komisja_lista = [k.strip() for k in komisja_input.strip().splitlines()]
                        context_header_footer = {
                            'rodzaj_szkolenia': f"Szkolenie wstƒôpne BHP dla stanowiska '{st.session_state.wybrany_zawod}'",
                            'data_egzaminu': data_koniec.strftime("%d.%m.%Y"), 'nr_kursu': nr_kursu,
                            'komisja_1_nazwisko': komisja_lista[0] if len(komisja_lista) > 0 else '',
                            'komisja_2_nazwisko': komisja_lista[1] if len(komisja_lista) > 1 else '',
                            'komisja_3_nazwisko': komisja_lista[2] if len(komisja_lista) > 2 else '',
                            'miejsce': miejscowosc, 'data_wystawienia': data_wystawienia_doc.strftime("%d.%m.%Y"),
                            'nazwa_organizatora': st.session_state.zapisana_firma
                        }
                        doc_tpl.render(context_header_footer)
                        temp_bio = BytesIO()
                        doc_tpl.save(temp_bio)
                        temp_bio.seek(0)

                        # Krok 2: Otw√≥rz wype≈Çniony dokument i dodaj wiersze do tabeli
                        doc = Document(temp_bio)
                        if doc.tables:
                            table = doc.tables[0]
                            for i, u in enumerate(uczestnicy_dane_lista):
                                row_cells = table.add_row().cells
                                row_cells[0].text = str(i + 1)
                                row_cells[1].text = u.get('imie_nazwisko', '')
                                row_cells[2].text = oceny_dict.get(u['imie_nazwisko'], 'brak')
                                row_cells[3].text = u.get('uwagi', '')
                            # Mo≈ºna dodaƒá kod do krawƒôdzi
                            final_bio = BytesIO()
                            doc.save(final_bio)
                            final_bio.seek(0)
                            st.download_button(label="Pobierz (.docx)", data=final_bio, file_name=f"Protokol_{st.session_state.wybrany_zawod}.docx", mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", key="dl_protokol")
                        else: st.error("Brak tabeli w szablonie.")
                    except Exception as e: st.error(f"B≈ÇƒÖd: {e}")
            else: st.warning("Wprowad≈∫ listƒô uczestnik√≥w i komisjƒô.")

    st.markdown("---")

    # --- Generowanie Dziennika Zajƒôƒá (NOWA METODA DLA TABELI + docxtpl dla reszty) ---
    with st.container(border=True):
        st.subheader("üóìÔ∏è Wygeneruj Dziennik Zajƒôƒá")
        data_zajec = st.date_input("Data zajƒôƒá:", key="dz_data", value=data_start)

        if st.button("Generuj Dziennik Zajƒôƒá", key="btn_dz_zajec"):
             with st.spinner("Generowanie..."):
                tematyka_z_godzinami = st.session_state.tematyka_z_godzinami
                if tematyka_z_godzinami:
                    try:
                        # Krok 1: Wype≈Çnij stopkƒô za pomocƒÖ docxtpl
                        doc_tpl = DocxTemplate("dziennik_zajec_szablon_uproszczony.docx") # <-- U≈ºywamy uproszczonego szablonu
                        context_footer = {'nazwa_organizatora': st.session_state.zapisana_firma}
                        doc_tpl.render(context_footer)
                        temp_bio = BytesIO()
                        doc_tpl.save(temp_bio)
                        temp_bio.seek(0)

                        # Krok 2: Otw√≥rz i dodaj wiersze do tabeli
                        doc = Document(temp_bio)
                        if doc.tables:
                            table = doc.tables[0]
                            zajecia_do_szablonu = [{'data': data_zajec.strftime("%d.%m.%Y"), 'godziny': t.get('godziny', '?'), 'przedmiot': "Szkolenie BHP", 'temat': t.get('nazwa', 'Brak tematu')} for t in tematyka_z_godzinami]
                            for i, z in enumerate(zajecia_do_szablonu):
                                row_cells = table.add_row().cells
                                row_cells[0].text = str(i + 1)
                                row_cells[1].text = z['data']
                                row_cells[2].text = str(z['godziny'])
                                row_cells[3].text = z['przedmiot']
                                row_cells[4].text = z['temat']
                                row_cells[5].text = "" # Podpis
                            # Mo≈ºna dodaƒá kod do krawƒôdzi
                            final_bio = BytesIO()
                            doc.save(final_bio)
                            final_bio.seek(0)
                            st.download_button(label="Pobierz (.docx)", data=final_bio, file_name=f"Dziennik_Zajec_{st.session_state.wybrany_zawod}.docx", mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", key="dl_dz_zajec")
                        else: st.error("Brak tabeli w szablonie.")
                    except Exception as e: st.error(f"B≈ÇƒÖd: {e}")
                else: st.error("Nie uda≈Ço siƒô wcze≈õniej wygenerowaƒá tematyki.")

    st.markdown("---")

# --- Sekcja generowania DZIENNIKA LEKCYJNEGO (NOWA METODA DLA TABELI + docxtpl dla reszty) ---
    with st.container(border=True):
         st.subheader("üìì Wygeneruj Dziennik Lekcyjny")
         st.info("Wprowad≈∫ dane wyk≈Çadowc√≥w.")
         st.caption("Format: Imiƒô Nazwisko, Miejsce Pracy, Funkcja (ka≈ºdy wyk≈Çadowca w nowej linii)")
         wykladowcy_input = st.text_area(
             "Wyk≈Çadowcy:",
             height=100,
             key="dz_lek_wykladowcy"
         )

         if st.button("Generuj Dziennik Lekcyjny", key="btn_dz_lek"):
             # Sprawdzenie 1: Czy pole nie jest puste?
             if not wykladowcy_input or not wykladowcy_input.strip():
                  st.warning("Wprowad≈∫ dane przynajmniej jednego wyk≈Çadowcy.")
             else:
                 with st.spinner("Przetwarzanie danych wyk≈Çadowc√≥w..."):

                    # Krok 1: Przetwarzanie danych wej≈õciowych z rygorystycznƒÖ walidacjƒÖ
                    wykladowcy_lista = []
                    bledne_linie = []
                    poprawne_linie_znaleziono = False
                    print("\n--- Rozpoczynam przetwarzanie wyk≈Çadowc√≥w ---") # Debug Start

                    if wykladowcy_input:
                        for i, linia in enumerate(wykladowcy_input.strip().splitlines()):
                            oryginalna_linia = linia.strip()
                            if not oryginalna_linia:
                                print(f"DEBUG: Linia {i+1} pominiƒôta (pusta).")
                                continue # Pomi≈Ñ puste linie

                            # Dzielimy tylko po pierwszym dw√≥ch przecinkach,
                            # agresywnie usuwamy bia≈Çe znaki
                            czesci_raw = linia.split(',', 2)
                            czesci = [czesc.strip() for czesc in czesci_raw if czesc.strip()] # Usu≈Ñ puste czƒô≈õci po strip()

                            print(f"DEBUG: Linia {i+1} Dziennika Lekcyjnego: Orygina≈Ç='{oryginalna_linia}', Po podziale={czesci_raw}, Po strip i filtracji={czesci}")

                            # NAJBARDZIEJ RYGORYSTYCZNE SPRAWDZENIE
                            if len(czesci) == 3:
                                # BEZPIECZNE TWORZENIE S≈ÅOWNIKA
                                wykladowcy_lista.append({
                                    'imie_nazwisko': czesci[0],
                                    'miejsce_pracy': czesci[1],
                                    'funkcja': czesci[2],
                                    'przedmiot': '', 'godziny_plan': 0, 'godziny_wykonanie': 0
                                })
                                poprawne_linie_znaleziono = True
                                print(f"DEBUG: Linia {i+1} przetworzona poprawnie.")
                            else: # Je≈õli len(czesci) jest inne ni≈º 3
                                bledne_linie.append(f"Linia {i+1} (niepoprawny format - znaleziono {len(czesci)} zamiast 3 czƒô≈õci): '{oryginalna_linia}'")
                                print(f"DEBUG: Linia {i+1} odrzucona (z≈Ça liczba czƒô≈õci).")

                    print(f"--- Zako≈Ñczono przetwarzanie. Poprawnych: {len(wykladowcy_lista)}, B≈Çƒôdnych: {len(bledne_linie)} ---") # Debug End

                    # Wy≈õwietl ostrze≈ºenia o b≈Çƒôdnych liniach
                    if bledne_linie:
                        st.warning("Niekt√≥re linie w polu 'Wyk≈Çadowcy' zosta≈Çy pominiƒôte:")
                        for blad in bledne_linie: st.warning(f"- {blad}")

                    # Sprawdzenie 2: Czy uda≈Ço siƒô przetworzyƒá *jakiekolwiek* poprawnie?
                    if not poprawne_linie_znaleziono:
                        st.error("Nie uda≈Ço siƒô przetworzyƒá ≈ºadnych danych wyk≈Çadowc√≥w. Sprawd≈∫ format (Imiƒô Nazwisko, Miejsce Pracy, Funkcja).")
                    else:
                        # Je≈õli mamy poprawne dane, kontynuuj generowanie
                        with st.spinner("Generowanie dokumentu Dziennika Lekcyjnego..."):
                            try:
                                doc_tpl = DocxTemplate("dziennik_lekcyjny_szablon_uproszczony.docx")
                                context_header = {
                                    'nazwa_organizatora': st.session_state.zapisana_firma,
                                    'dla_kogo': f"Szkolenie dla {st.session_state.wybrany_zawod}",
                                    'data_od': data_start.strftime("%d.%m.%Y"), 'data_do': data_koniec.strftime("%d.%m.%Y"),
                                    'miejsce': miejscowosc, 'kierownik_nazwisko': kierownik_kursu,
                                    'kierownik_miejsce_pracy_funkcja': "Kierownik Szkolenia"
                                }
                                doc_tpl.render(context_header)
                                temp_bio = BytesIO()
                                doc_tpl.save(temp_bio)
                                temp_bio.seek(0)
                                doc = Document(temp_bio)

                                tematyka_z_godzinami = st.session_state.tematyka_z_godzinami
                                total_godziny_plan = 0
                                total_godziny_wykonanie = 0
                                
                                for w in wykladowcy_lista:
                                    w['przedmiot'] = ''
                                    w['godziny_plan'] = 0
                                    w['godziny_wykonanie'] = 0

                                if tematyka_z_godzinami:
                             # Upewniamy siƒô, ≈ºe wykladowcy_lista na pewno nie jest pusta
                                    if wykladowcy_lista:
                                        for i, temat in enumerate(tematyka_z_godzinami):
                                      # Sprawdzamy czy 'temat' jest s≈Çownikiem i ma klucz 'godziny'
                                            if isinstance(temat, dict) and 'godziny' in temat:
                                                idx_wykladowcy = i % len(wykladowcy_lista) # R√≥wnomierny podzia≈Ç
                                                godziny_tematu = temat.get('godziny', 0)
                                          # Sprawdzenie typu przed dodaniem
                                                if isinstance(godziny_tematu, int):
                                              # Sprawdzamy czy indeks jest poprawny
                                                    if idx_wykladowcy < len(wykladowcy_lista):
                                                     wykladowcy_lista[idx_wykladowcy]['przedmiot'] += temat.get('nazwa', 'Brak nazwy tematu') + "\n"
                                                    wykladowcy_lista[idx_wykladowcy]['godziny_plan'] += godziny_tematu
                                                    wykladowcy_lista[idx_wykladowcy]['godziny_wykonanie'] += godziny_tematu
                                                    total_godziny_plan += godziny_tematu
                                                    total_godziny_wykonanie += godziny_tematu
                                                else:
                                                  print(f"DEBUG: B≈ÇƒÖd indeksu wyk≈Çadowcy {idx_wykladowcy} przy li≈õcie o d≈Çugo≈õci {len(wykladowcy_lista)}")
                                            else:
                                               st.warning(f"Pominiƒôto godziny dla tematu '{temat.get('nazwa', '')}' - nieprawid≈Çowy format godzin.")
                                        else:
                                          st.warning(f"Pominiƒôto temat nr {i+1} - nieprawid≈Çowy format danych tematyki.")
                                    else:
                                        st.warning("Brak poprawnych danych wyk≈Çadowc√≥w do przypisania temat√≥w.")
                                else:
                                    st.warning("Brak danych o tematyce szkolenia do przypisania wyk≈Çadowcom.")

                                if doc.tables and len(doc.tables) > 0:
                                    table = doc.tables[0]
                                    for i, w in enumerate(wykladowcy_lista):
                                        # Bezpieczny dostƒôp do danych wyk≈Çadowcy
                                        row_cells = table.add_row().cells
                                        if len(row_cells) >= 7: # Sprawd≈∫ liczbƒô kom√≥rek
                                            row_cells[0].text = str(i + 1)
                                            row_cells[1].text = w.get('imie_nazwisko', '')
                                            row_cells[2].text = w.get('miejsce_pracy', '')
                                            row_cells[3].text = w.get('funkcja', '')
                                            row_cells[4].text = w.get('przedmiot', '').strip()
                                            row_cells[5].text = str(w.get('godziny_plan', 0))
                                            row_cells[6].text = str(w.get('godziny_wykonanie', 0))
                                        else:
                                            print(f"DEBUG: Nieprawid≈Çowa liczba kom√≥rek w wierszu {i+1} tabeli Dziennika Lekcyjnego.")


                                    row_cells = table.add_row().cells
                                    if len(row_cells) >= 7:
                                        row_cells[4].text = "Razem:"
                                        row_cells[5].text = str(total_godziny_plan)
                                        row_cells[6].text = str(total_godziny_wykonanie)

                                    final_bio = BytesIO()
                                    doc.save(final_bio)
                                    final_bio.seek(0)
                                    st.download_button(label="Pobierz Dziennik Lekcyjny (.docx)", data=final_bio, file_name=f"Dziennik_Lekcyjny_{st.session_state.wybrany_zawod}.docx", mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", key="dl_dz_lek")
                                else:
                                    st.error("Brak tabeli w szablonie 'dziennik_lekcyjny_szablon_uproszczony.docx'.")
                            except Exception as e:
                                   st.error(f"WystƒÖpi≈Ç b≈ÇƒÖd podczas generowania Dziennika Lekcyjnego: {e}")
                                   st.warning("Upewnij siƒô, ≈ºe plik szablonu istnieje.")

    st.markdown("---")# Ten separator powinien byƒá na poprawnym poziomie
    
    # --- Generowanie Rejestru Za≈õwiadcze≈Ñ (NOWA METODA DLA TABELI + docxtpl dla reszty) ---
    with st.container(border=True):
        st.subheader("üìö Wygeneruj Rejestr Wydanych Za≈õwiadcze≈Ñ")
        if st.button("Generuj Rejestr", key="btn_rejestr"):
            if uczestnicy_dane_lista:
                with st.spinner("Generowanie..."):
                    try:
                        # Krok 1: Wype≈Çnij nag≈Ç√≥wek i stopkƒô za pomocƒÖ docxtpl
                        doc_tpl = DocxTemplate("rejestr_zaswiadczen_szablon_uproszczony.docx") # <-- U≈ºywamy uproszczonego szablonu
                        context_header_footer = {
                            'rodzaj_szkolenia': "wstƒôpnego", 'nr_kursu': nr_kursu,
                            'kierownik_nazwisko': kierownik_kursu,
                            'data_wystawienia': data_wystawienia_doc.strftime("%d.%m.%Y"),
                            'nazwa_organizatora': st.session_state.zapisana_firma
                        }
                        doc_tpl.render(context_header_footer)
                        temp_bio = BytesIO()
                        doc_tpl.save(temp_bio)
                        temp_bio.seek(0)

                        # Krok 2: Otw√≥rz i dodaj wiersze do tabeli
                        doc = Document(temp_bio)
                        if doc.tables:
                            table = doc.tables[0]
                            zaswiadczenia_do_rejestru = [{'numer': f"{nr_kursu}/{i+1}", 'imie_nazwisko': u['imie_nazwisko'], 'uwagi': ''} for i, u in enumerate(uczestnicy_dane_lista)]
                            for i, z in enumerate(zaswiadczenia_do_rejestru):
                                row_cells = table.add_row().cells
                                row_cells[0].text = z['numer']
                                row_cells[1].text = z['imie_nazwisko']
                                row_cells[2].text = "" # Podpis
                                row_cells[3].text = z['uwagi']
                            # Mo≈ºna dodaƒá kod do krawƒôdzi
                            final_bio = BytesIO()
                            doc.save(final_bio)
                            final_bio.seek(0)
                            st.download_button(label="Pobierz (.docx)", data=final_bio, file_name=f"Rejestr_{st.session_state.wybrany_zawod}.docx", mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", key="dl_rejestr")
                        else: st.error("Brak tabeli w szablonie.")
                    except Exception as e: st.error(f"B≈ÇƒÖd: {e}")
            else: st.warning("Wprowad≈∫ listƒô uczestnik√≥w.")
    
    st.markdown("---")

    # --- Sekcja generowania TESTU SPRAWDZAJƒÑCEGO ---
    with st.container(border=True):
        st.subheader("üìù Wygeneruj Test SprawdzajƒÖcy")
        st.info("Aplikacja przeanalizuje ca≈ÇƒÖ tre≈õƒá szkolenia i na jej podstawie stworzy test.")

        if st.button("Generuj Test", key="btn_test"):
            with st.spinner("Generowanie testu (to mo≈ºe chwilƒô potrwaƒá)..."):
                # Wywo≈Çujemy nowƒÖ funkcjƒô AI, przekazujƒÖc jej ca≈ÇƒÖ tre≈õƒá
                tresc_testu_wygenerowana = generuj_test_bhp(st.session_state.finalna_tresc)
                
                if "Nie uda≈Ço siƒô wygenerowaƒá testu" not in tresc_testu_wygenerowana:
                    context = {
                        'nazwa_szkolenia': f"Szkolenie wstƒôpne BHP dla stanowiska '{st.session_state.wybrany_zawod}'",
                        'tresc_testu': tresc_testu_wygenerowana
                    }
                    
                    # U≈ºywamy naszej istniejƒÖcej funkcji generuj_docx
                    plik_docx = generuj_docx("test_szablon.docx", context, f"Test_{st.session_state.wybrany_zawod}.docx")
                    
                    if plik_docx:
                        st.download_button(
                            label="Pobierz gotowy test (.docx)",
                            data=plik_docx,
                            file_name=f"Test_{st.session_state.wybrany_zawod}.docx",
                            mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                            key="download_test"
                        )
                else:
                    st.error("Nie uda≈Ço siƒô wygenerowaƒá tre≈õci testu.")

    st.markdown("---")

    if st.button("Stw√≥rz zupe≈Çnie nowe szkolenie"):
        st.session_state.etap = 1
        st.rerun()
